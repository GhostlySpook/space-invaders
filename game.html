<canvas id="gameCanvas" width="800" height="600"></canvas>
<button id="startButton" onClick="restartGame()">Restart Game</button>
<canvas id = "debuggingCanvas" width="800" height="600"></canvas>
<script>
    //Define canvas
    var gameCanvas = document.getElementById("gameCanvas");
    var ctx = gameCanvas.getContext("2d");
    
    //Load images
    var imgAlien = new Image();
    //imgAlien.src = "http://s3.amazonaws.com/gt7sp-prod/decal/76/67/97/4621335403474976776_1.png";
    imgAlien.src = "Invader.png";

    var imgDefender = new Image();
    //imgDefender.src = "https://pixelartmaker-data-78746291193.nyc3.digitaloceanspaces.com/image/e4af22756166f44.png";
    imgDefender.src = "Defender.png";

    var imgDefenderExplode1 = new Image();
    imgDefenderExplode1.src = "DefenderExplode1.png";

    var imgDefenderExplode2 = new Image();
    imgDefenderExplode2.src = "DefenderExplode2.png";

    var imgProjectile = new Image();
    imgProjectile.src = "Bullet.png";

    var imgEnemyProjectile = new Image();
    imgEnemyProjectile.src = "EnemyProjectile.png";

    var imgUFO = new Image();
    imgUFO.src = "UFO.png";

    var imgShield = new Image();
    imgShield.src = "Shield.png";

    var imgExplosion = new Image();
    imgExplosion.src = "Explosion.png";

    var imgAlienExplosion = new Image();
    imgAlienExplosion.src = "EnemyExplosion.png";

    var imgAlienProjectileExplosion = new Image();
    imgAlienProjectileExplosion.src = "AlienProjectileExplosion.png";

    //////////////////////////////////
    //Game parameters
    //var gameStarted = 0;
    var fractions = 60;
    var timeFraction = 1000 / fractions;
    var screenWidth = 800;
    var screenHeight = 600;

    var defaultLives = 3;
    var defaultHighscore = 1000;
    
    //Player settings
    var playerSpeed = 4;
    var playerInitialPosX = 385;
    var playerInitialPosY = 530;
    var playerLimitXLeft = 50;
    var playerLimitXRight = 750;

    var playerHeight = 20;
    var playerWidth = 40;

    var playerProjectileHeight = 20;
    var playerProjectileWidth = 2;
    var maxPlayerProjectiles = 1;
    var playerProjectileReloadTime = 20;
    var playerProjectileSpeed = 10;
    var playerProjectileYLimit = 50;

    var downedAnimationDelay = 1000 / (5/*FPS*/);
    var downedLoops = 12;

    //Alien settings
    var alienRows = 5;
    var alienColumns = 11;

    var alienHeight = 22;
    var alienWidth = 45;
    var alienDirection = 1;
    var alienXMoveDistance = 7;
    var alienYMoveDistance = 10;
    var alienDefaultFPSForMovement = 12;
    var alienDefaultFPSForProjectile = 120;

    var alienReduceFPSWaitPercentage = 0.97;

    var alienXLimitLeft = 50;
    var alienXLimitRight = 750;
    var alienXSeparation = 10;
    var alienYSeparation = 15;
    var alienYStart = 100;

    var alienPoints = 10;
    var alienFrozenTime = playerProjectileReloadTime;

    //Enemy projectile settings
    var enemyProjectileYLimit = 545;
    var enemyProjectileSpeed = 5;
    var enemyProjectileChance = 1;
    var enemyMaxProjectiles = 5;

    var enemyProjectileHeight = 20;
    var enemyProjectileWidth = 8;

    //UFO settings
    var UFOSpeed = 3;
    var UFOPoints = 50;
    var UFOFramesForSpawn = fractions * 30; //FPS of game times the seconds each UFO takes to spawn
    var UFOWidth = 50;
    var UFOHeight = 20;
    var UFOXLeftLimit = 0; //Disappear once the left part touches the edge
    var UFOXRightLimit = screenWidth; //UFO should disappear once the right part touches the limit
    var UFOYSpawn = 60;
    const UFODirections = {
        RIGHT: 0,
        LEFT: 1
    }

    //Shield settings
    var defaultShields = 4;
    var defaultShieldHealth = 5;
    var defaultShieldWidth = 90;
    var defaultShieldHeight = 40;
    var defaultShieldPosY = 450;

    //Temp Sprites settings
    //Explosions take the same time it takes for your projectile to disappear
    var tempSpriteExplosionWidth = 25;
    var tempSpriteExplosionHeight = alienHeight;
    var tempSpriteExplosionDuration = playerProjectileReloadTime;

    var tempSpriteEnemyExplosionWidth = alienWidth;
    var tempSpriteEnemyExplosionHeight = alienHeight;
    var tempSpriteEnemyExplosionDuration = playerProjectileReloadTime;

    var tempSpriteAlienProjectileExplosionWidth = 20;
    var tempSpriteAlienProjectileExplosionHeight = 20;
    var tempSpriteAlienProjectileExplosionDuration = 20;

    //End of parameters

    //////////////////////////////////////////
    //Create projectile explosion shape for destruction and shield shape
    let conversionCanvas = document.createElement("canvas");
    let conversionCtx = conversionCanvas.getContext("2d");

    let debuggingCanvas = document.getElementById("debuggingCanvas");
    let debuggingCtx = debuggingCanvas.getContext("2d");
    debuggingCanvas.style.background = "pink";

    var defaultDestructibleObject;
    var playerProjectileObject;
    var playerProjectileExplosionObject;
    var enemyProjectileObject;
    var enemyProjectileExplosionObject;

    //Take imagedata and create a smaller shape resizing the image
    imgShield.onload = () => {        
        conversionCanvas.width = defaultShieldWidth;
        conversionCanvas.height = defaultShieldHeight;
        conversionCtx.clearRect(0, 0, conversionCanvas.width, conversionCanvas.height);
        conversionCtx.drawImage(imgShield, 0, 0, defaultShieldWidth, defaultShieldHeight);
        let shieldImageData = conversionCtx.getImageData(0, 0, defaultShieldWidth, defaultShieldHeight);

        //This kind of object will have pixels which will act with their own hit detection
        defaultDestructibleObject = {
            data: [],
            width: defaultShieldWidth,
            height: defaultShieldHeight
        };
        
        for(let imagePointer = 3, destructiblePointer = 0; imagePointer < shieldImageData.data.length; imagePointer+=4, destructiblePointer++){
            //If it isn't transparent, add a hit pixel
            if(shieldImageData.data[imagePointer] != 0){
                defaultDestructibleObject.data[destructiblePointer] = 1;
            }
            else{
                defaultDestructibleObject.data[destructiblePointer] = 0;
            }
        }

        console.log("Test", defaultDestructibleObject);
    }

    imgProjectile.onload = () => {        
        conversionCanvas.width = playerProjectileWidth;
        conversionCanvas.height = playerProjectileHeight;
        conversionCtx.clearRect(0, 0, conversionCanvas.width, conversionCanvas.height);
        conversionCtx.drawImage(imgProjectile, 0, 0, playerProjectileWidth, playerProjectileHeight);
        let projectileImageData = conversionCtx.getImageData(0, 0, playerProjectileWidth, playerProjectileHeight);

        //This kind of object will have pixels which will act with their own hit detection
        playerProjectileObject = {
            data: [],
            width: playerProjectileWidth,
            height: playerProjectileHeight
        };
        
        for(let imagePointer = 3, destructiblePointer = 0; imagePointer < projectileImageData.data.length; imagePointer+=4, destructiblePointer++){
            //If it isn't transparent, add a hit pixel
            if(projectileImageData.data[imagePointer] != 0){
                playerProjectileObject.data[destructiblePointer] = 1;
            }
            else{
                playerProjectileObject.data[destructiblePointer] = 0;
            }
        }
    }

    imgExplosion.onload = () => {        
        conversionCanvas.width = tempSpriteExplosionWidth;
        conversionCanvas.height = tempSpriteExplosionHeight;
        conversionCtx.clearRect(0, 0, conversionCanvas.width, conversionCanvas.height);
        conversionCtx.drawImage(imgExplosion, 0, 0, tempSpriteExplosionWidth, tempSpriteExplosionHeight);
        let explosionImageData = conversionCtx.getImageData(0, 0, tempSpriteExplosionWidth, tempSpriteExplosionHeight);

        //This kind of object will have pixels which will act with their own hit detection
        playerProjectileExplosionObject = {
            data: [],
            width: tempSpriteExplosionWidth,
            height: tempSpriteExplosionHeight
        };
        
        for(let imagePointer = 3, destructiblePointer = 0; imagePointer < explosionImageData.data.length; imagePointer+=4, destructiblePointer++){
            //If it isn't transparent, add a hit pixel
            if(explosionImageData.data[imagePointer] != 0){
                playerProjectileExplosionObject.data[destructiblePointer] = 1;
            }
            else{
                playerProjectileExplosionObject.data[destructiblePointer] = 0;
            }
        }
    }

    imgEnemyProjectile.onload = () => {        
        conversionCanvas.width = enemyProjectileWidth;
        conversionCanvas.height = enemyProjectileHeight;
        conversionCtx.clearRect(0, 0, conversionCanvas.width, conversionCanvas.height);
        conversionCtx.drawImage(imgEnemyProjectile, 0, 0, enemyProjectileWidth, enemyProjectileHeight);
        let projectileImageData = conversionCtx.getImageData(0, 0, enemyProjectileWidth, enemyProjectileHeight);

        //This kind of object will have pixels which will act with their own hit detection
        enemyProjectileObject = {
            data: [],
            width: enemyProjectileWidth,
            height: enemyProjectileHeight
        };
        
        for(let imagePointer = 3, destructiblePointer = 0; imagePointer < projectileImageData.data.length; imagePointer+=4, destructiblePointer++){
            //If it isn't transparent, add a hit pixel
            if(enemyProjectileObject.data[imagePointer] != 0){
                enemyProjectileObject.data[destructiblePointer] = 1;
            }
            else{
                enemyProjectileObject.data[destructiblePointer] = 0;
            }
        }
    }

    imgAlienProjectileExplosion.onload = () => {        
        conversionCanvas.width = tempSpriteAlienProjectileExplosionWidth;
        conversionCanvas.height = tempSpriteAlienProjectileExplosionHeight;
        conversionCtx.clearRect(0, 0, conversionCanvas.width, conversionCanvas.height);
        conversionCtx.drawImage(imgAlienProjectileExplosion, 0, 0, tempSpriteAlienProjectileExplosionWidth, tempSpriteAlienProjectileExplosionHeight);
        let explosionImageData = conversionCtx.getImageData(0, 0, tempSpriteAlienProjectileExplosionWidth, tempSpriteAlienProjectileExplosionHeight);

        //This kind of object will have pixels which will act with their own hit detection
        enemyProjectileExplosionObject = {
            data: [],
            width: tempSpriteAlienProjectileExplosionWidth,
            height: tempSpriteAlienProjectileExplosionHeight
        };
        
        for(let imagePointer = 3, destructiblePointer = 0; imagePointer < explosionImageData.data.length; imagePointer+=4, destructiblePointer++){
            //If it isn't transparent, add a hit pixel
            if(explosionImageData.data[imagePointer] != 0){
                enemyProjectileExplosionObject.data[destructiblePointer] = 1;
            }
            else{
                enemyProjectileExplosionObject.data[destructiblePointer] = 0;
            }
        }

        //console.log(alienProjectileExplosionObject);
    }

    //Start loop
    var gameInterval;

    var score = 0;
    var highScore = defaultHighscore;
    
    var lives = defaultLives;
    var playerPosX = playerInitialPosX;
    var playerPosY = playerInitialPosY;
    var playerProjectileList = [];
    var playerProjectileCurrentReload = 0;
    var playerCurrentImage = imgDefender;

    //Player lost life related
    var playerDownedCurrent = 0;
    var downedCurrentLoop = 0;

    var keyLeft = false;
    var keyRight = false;
    var keyShoot = false;

    var alienList = [];
    var alienX = 0;
    var alienY = alienYStart;
    var alienMovementFPS = 0;
    var alienAcceleratedFPS = alienDefaultFPSForMovement;
    var alienFlagDirection = false;
    var alienReadyChangeDirection = false;
    var alienMovementRows = [];
    var alienCurrentMovementIndex = 0;

    var alienCurrentFrozenTime = 0;
    var bottomAliens = [];

    var enemyProjectileList = [];
    var alienProjectileFPS = 0;

    var UFOCountSpawnFPS = 0;
    var UFOList = [];

    var shieldList = [];

    var tempSpriteList = [];

    var gameLoop = () => {
        //Drawing function to draw everything
        drawItems();

        handleInput();

        //Reduce reload waiting time
        if(playerProjectileCurrentReload >= 0){
            playerProjectileCurrentReload--;
        }
        
        //Move aliens when the time arrives and there ARE aliens, check if aliens aren't frozen too
        if(alienCurrentFrozenTime >= 0){
            alienCurrentFrozenTime--;
        }
        else{
            if(alienAcceleratedFPS <= alienMovementFPS && alienList.length > 0){
                //console.log("Current alien direction: ", alienDirection)
                //console.log("Alien moving row: ", alienCurrentMovementIndex);
                listLength = alienList.length;
                let lastRow = alienMovementRows[(alienMovementRows.length - 1)]

                //If it is time to make the aliens change directions, do and move
                if(alienReadyChangeDirection){
                    if((alienMovementRows.length - 1) == alienCurrentMovementIndex){
                        alienDirection *= -1;
                    }

                    for(let alienNo = 0; alienNo < listLength; alienNo++){
                        if(alienList[alienNo].row == alienMovementRows[alienCurrentMovementIndex]){
                            alienList[alienNo].posX += alienDirection * alienXMoveDistance;
                            alienList[alienNo].posY += alienYMoveDistance;
                        }

                        if((alienList[alienNo].posX + alienList[alienNo].width > alienXLimitRight || alienList[alienNo].posX < alienXLimitLeft)){
                            alienFlagDirection = true;
                        }

                        if(alienCurrentMovementIndex == 0){
                            alienFlagDirection = false;
                            alienReadyChangeDirection = false;
                        }
                    }
                }
                else{
                    //If not, move normally
                    for(let alienNo = 0; alienNo < listLength; alienNo++){
                        if(alienList[alienNo].row == alienMovementRows[alienCurrentMovementIndex]){
                            alienList[alienNo].posX += alienDirection * alienXMoveDistance;
                        }

                        if((alienList[alienNo].posX + alienList[alienNo].width > alienXLimitRight || alienList[alienNo].posX < alienXLimitLeft)){
                            alienFlagDirection = true;
                        }
                    }
                }

                if(alienCurrentMovementIndex == 0 && alienFlagDirection == true){
                    alienReadyChangeDirection = true;
                }

                alienMovementFPS = 0;

                alienCurrentMovementIndex--;
                if(alienCurrentMovementIndex < 0){
                    alienCurrentMovementIndex = alienMovementRows.length - 1;
                }
            }
            else{
                alienMovementFPS++;
            }
        }

        //Collision with shields or player by bottom aliens
        for(let i = 0; i < alienList.length; i++){
            let currentAlien = alienList[i];

            for(let shieldNo = 0; shieldNo < shieldList.length; shieldNo++){
                //Collision with shields!
                let currentShield = shieldList[shieldNo];

                if(checkCollision(currentAlien.posX, currentAlien.width, 
                    currentAlien.posY, currentAlien.height, 
                    currentShield.posX, currentShield.width, 
                    currentShield.posY, currentShield.height)){

                    if(checkPixelCollision(currentShield.posX, currentShield.posY, currentShield.width, currentShield.height, currentShield.pixelCollision,
                    currentAlien.posX, currentAlien.posY, currentAlien.width, currentAlien.height, currentAlien.pixelCollision)){
                        damageShield(currentShield, currentAlien.pixelCollision, currentAlien.posX, currentAlien.posY);
                    }
                }
            }

            //Collision with the player
            if(checkCollision(currentAlien.posX, currentAlien.width, 
                    currentAlien.posY, currentAlien.height, 
                    playerPosX, playerWidth, 
                    playerPosY, playerHeight)){
                
                loseLife();
            }
        }

        //Create UFOs
        if(UFOCountSpawnFPS >= UFOFramesForSpawn){
            //console.log("Created UFO!");
            //Choose whether the UFO moves to the left or to the right
            let direction = Math.floor(Math.random() * 2);

            //If the direction is to go right
            if(direction == UFODirections.RIGHT){
                //Spawn on the left side
                posX = UFOXLeftLimit;
            }
            else{
                posX = UFOXRightLimit;
            }

            let newUFO = {
                direction: direction,
                width: UFOWidth,
                height: UFOHeight,
                posX: posX,
                posY: UFOYSpawn
            }

            UFOList.push(newUFO);

            UFOCountSpawnFPS = 0;
        }
        else{
            UFOCountSpawnFPS++;
        }
        
        //Move UFOS
        for(let i = 0; i < UFOList.length; i++){
            let currentUFO = UFOList[i];

            //When the UFO is going right
            if(currentUFO.direction == UFODirections.RIGHT){
                //Do the movement
                currentUFO.posX += UFOSpeed;
            
                //Check if the UFO has reached the limit (Check the direction it is going). This case, if it reached the right side
                if(currentUFO.posX + currentUFO.width >= UFOXRightLimit){
                    //Delete the UFO! in the current position
                    UFOList.splice(i, 1);
                    i--;
                    continue
                }
            }
            else{
                //Same to case above
                currentUFO.posX -= UFOSpeed;

                if(currentUFO.posX <= UFOXLeftLimit){
                    //Delete the UFO! in the current position
                    UFOList.splice(i, 1);
                    i--;
                    continue
                }
            }
        }

        //Create enemy projectiles
        if(alienDefaultFPSForProjectile <= alienProjectileFPS && alienList.length > 0 && alienCurrentFrozenTime <= 0){
            listLength = alienList.length;

            //Select a random alien from the bottom and shoot
            let randomAlien = bottomAliens[Math.floor(Math.random() * bottomAliens.length)];

            let projectileX = randomAlien.posX + (randomAlien.width / 2);

            let newPixelCollision = {
                data: enemyProjectileObject.data.slice(),
                width: enemyProjectileWidth,
                height: enemyProjectileHeight
            };

            let enemyProjectile = {
                posX: projectileX,
                posY: (randomAlien.posY + randomAlien.height),
                width: enemyProjectileWidth,
                height: enemyProjectileHeight,
                pixelCollision: newPixelCollision
            };

            //console.log(enemyProjectile);

            enemyProjectileList.push(enemyProjectile);

            alienProjectileFPS = 0;
        }
        else{
            alienProjectileFPS++;
        }
        
        //Move friendly projectile
        let playerProjectileListLength = playerProjectileList.length;
        for(let i = 0; i < playerProjectileListLength; i++){
            let currentProjectile = playerProjectileList[i];
            currentProjectile.posY -= playerProjectileSpeed;
        }

        //Move enemy projectile
        let enemyProjectileLength = enemyProjectileList.length;
        for(let i = 0; i < enemyProjectileLength; i++){
            let currentProjectile = enemyProjectileList[i];
            currentProjectile.posY += enemyProjectileSpeed;
        }

        //Check collision on player projectile
        for(let projectileNo = 0; projectileNo < playerProjectileList.length; projectileNo++){
            let removeProjectile = false;

            let currentProjectile = playerProjectileList[projectileNo];

            //Check if projectile hits shield

            for(let shieldNo = 0; shieldNo < shieldList.length; shieldNo++){
                let currentShield = shieldList[shieldNo];

                //Projectile hits shield
                if(checkCollision(currentProjectile.posX, currentProjectile.width, 
                currentProjectile.posY, currentProjectile.height, 
                currentShield.posX, currentShield.width, 
                currentShield.posY, currentShield.height)){
                    //console.log("Projectile is in shield proximity");

                    //console.log("Projectile:", currentProjectile);
                    //console.log("Shield:", currentShield);

                    if(checkPixelCollision(currentShield.posX, currentShield.posY, currentShield.width, currentShield.height, currentShield.pixelCollision,
                    currentProjectile.posX, currentProjectile.posY, currentProjectile.width, currentProjectile.height, currentProjectile.pixelCollision)){
                        //console.log("Projectile collided with shield");
                        
                        /*if(currentShield.health <= 0){
                            shieldList.splice(shieldNo, 1);
                            //Creo que no se ocupa al ser destruido el proyectil
                            //shieldNo--;
                        }*/

                        //Deal damage to shield
                        let projectileCenterX = currentProjectile.posX + currentProjectile.width / 2;
                        let explosionCenterX = projectileCenterX - playerProjectileExplosionObject.width / 2;

                        //console.log("playerProjectileExplosion: ", playerProjectileExplosionObject);

                        //Generate new image for the shield alongside dealing damage
                        damageShield(currentShield, playerProjectileExplosionObject, explosionCenterX, currentProjectile.posY);
                        
                        /*conversionCanvas.width = defaultShieldWidth
                        conversionCanvas.height = defaultShieldHeight;
                        conversionCtx.clearRect(0, 0, conversionCanvas.width, conversionCanvas.height);
                        conversionCtx.drawImage(imgShield, 0, 0, defaultShieldWidth, defaultShieldHeight);
                        currentShield.image = conversionCtx.getImageData(0, 0, defaultShieldWidth, defaultShieldHeight);*/

                        removeProjectile = true;
                        break;
                    }


                        /*currentShield.health--;

                        if(currentShield.health <= 0){
                            shieldList.splice(shieldNo, 1);
                            //Creo que no se ocupa al ser destruido el proyectil
                            //shieldNo--;
                        }*/
                }

            }

            if(removeProjectile){
                playerProjectileList.splice(projectileNo, 1);
                projectileNo--;
                continue;
            }

            //Check if projectile hits alien
            for(let alienNo = 0; alienNo < alienList.length; alienNo++){
                //console.log(alienNo);
                let currentAlien = alienList[alienNo];

                //Check if alien was hit!
                if(checkCollision(currentProjectile.posX, currentProjectile.width, 
                currentProjectile.posY, currentProjectile.height, 
                currentAlien.posX, currentAlien.width, 
                currentAlien.posY, currentAlien.height)){
                    /*console.log("Pre-shot:");
                    console.log("Alien list: ", alienList);
                    console.log("Moving rows: ", alienMovementRows);*/

                    addScore(alienPoints);
                    //console.log(alienAcceleratedFPS);

                    let currentPosX = currentAlien.posX;
                    let currentPosY = currentAlien.posY;
                    let currentColumn = currentAlien.column;
                    let currentRow = currentAlien.row;
                    alienList.splice(alienNo, 1);
                    //console.log("Removing alien no: ", alienNo);
                    removeProjectile = true;

                    //Update aliens in bottom to know which should keep shooting
                    let lowestAlien = null;
                    for(let i = 0; i < alienList.length; i++){
                        if(currentColumn == alienList[i].column){
                            if(lowestAlien == null){
                                lowestAlien = alienList[i];
                            }
                            else if(lowestAlien.row < alienList[i].row){
                                lowestAlien = alienList[i];
                            }
                        }
                    }

                    if(lowestAlien != null){
                        bottomAliens.push(lowestAlien);
                    }

                    bottomAliens = bottomAliens.filter(alien => !(alien.row == currentRow && alien.column == currentColumn));

                    //Update living rows for aliens
                    //If there aren't any aliens in the row, then remove the row from the movement queue and make index go down to one
                    let tempList = alienList.filter(alien => alien.row == currentRow);
                    //console.log("Living alien in row:", tempList);
                    if(tempList.length <= 0){
                        let indexToDelete = alienMovementRows.findIndex(row => currentRow == row);
                        alienMovementRows.splice(indexToDelete, 1);
                        if(indexToDelete <= alienCurrentMovementIndex){
                            alienCurrentMovementIndex--;
                            if(alienCurrentMovementIndex < 0){
                                alienCurrentMovementIndex = alienMovementRows.length - 1;
                            }
                        }
                    }

                    speedAliensUp();

                    //Create an explosion from the aliens!
                    //Get the center of the alien and draw it there! Since it is the same size as the alien, just use their same position and measures
                    addTempSprite(imgAlienExplosion, tempSpriteEnemyExplosionDuration, currentPosX, currentPosY, tempSpriteEnemyExplosionWidth, tempSpriteEnemyExplosionHeight);
                    playerProjectileCurrentReload = playerProjectileReloadTime;

                    alienCurrentFrozenTime = alienFrozenTime;

                    /*console.log("Post-shot:");
                    console.log("Alien list: ", alienList);
                    console.log("Moving rows: ", alienMovementRows);*/

                    break;
                }
            }

            if(removeProjectile){
                playerProjectileList.splice(projectileNo, 1);
                projectileNo--;
                continue;
            }


            //Check if projectile hits UFO
            for(let UFONo = 0; UFONo < UFOList.length; UFONo++){
                let currentUFO = UFOList[UFONo];

                if(checkCollision(currentProjectile.posX, currentProjectile.width, 
                currentProjectile.posY, currentProjectile.height, 
                currentUFO.posX, currentUFO.width, 
                currentUFO.posY, currentUFO.height)){

                        //Give random points after hitting!
                        addScore(Math.floor(Math.random() * 6) * 50 + 50); //Score generated should be from 50 to 300
                        
                        //Remove UFO
                        UFOList.splice(UFONo, 1);

                        removeProjectile = true;

                        //Because the projectile is destroyed, stop iterating what it could hit
                        break;
                }
            }

            if(removeProjectile){
                playerProjectileList.splice(projectileNo, 1);
                projectileNo--;
                continue;
            }

            //Check if projectile hits enemy projectile
            for(let enemyProjectileNo = 0; enemyProjectileNo < enemyProjectileList.length; enemyProjectileNo++){
                let current = enemyProjectileList[enemyProjectileNo];

                if(checkCollision(currentProjectile.posX, currentProjectile.width, 
                currentProjectile.posY, currentProjectile.height, 
                current.posX, current.width, 
                current.posY, current.height)){

                    //Draw the explosion! Get the center of x position, but not y
                    //Leave the explosion on the center of the projectile
                    let explosionX = (currentProjectile.posX + currentProjectile.width / 2) - (tempSpriteExplosionWidth / 2);

                    addTempSprite(imgExplosion, tempSpriteExplosionDuration, explosionX, currentProjectile.posY, tempSpriteExplosionWidth, tempSpriteExplosionHeight);
                    playerProjectileCurrentReload = playerProjectileReloadTime;

                    enemyProjectileList.splice(enemyProjectileNo, 1);
                    removeProjectile = true;
                    break;
                }
            }

            if(removeProjectile){
                playerProjectileList.splice(projectileNo, 1);
                projectileNo--;
                continue;
            }

            //Projectile reaches end of screen
            if(currentProjectile.posY <= playerProjectileYLimit){

                //Draw the explosion! Get the center of x position, but not y
                //Leave the explosion on the center of the projectile
                let explosionX = (currentProjectile.posX + currentProjectile.width / 2) - (tempSpriteExplosionWidth / 2);

                addTempSprite(imgExplosion, tempSpriteExplosionDuration, explosionX, currentProjectile.posY, tempSpriteExplosionWidth, tempSpriteExplosionHeight);
                playerProjectileCurrentReload = playerProjectileReloadTime;

                playerProjectileList.splice(projectileNo, 1);
                projectileNo--;
            }

        }

        //Check collision of enemy projectile
        for(let projectileNo = 0; projectileNo < enemyProjectileList.length; projectileNo++){
            let removeProjectile = false;

            let currentProjectile = enemyProjectileList[projectileNo];

            //Check if projectile hits shield

            for(let shieldNo = 0; shieldNo < shieldList.length; shieldNo++){
                let currentShield = shieldList[shieldNo];

                //Projectile hit shield!
                if(checkCollision(currentProjectile.posX, currentProjectile.width, 
                currentProjectile.posY, currentProjectile.height, 
                currentShield.posX, currentShield.width, 
                currentShield.posY, currentShield.height)){
                    //currentShield.health--;

                    if(checkPixelCollision(currentShield.posX, currentShield.posY, currentShield.width, currentShield.height, currentShield.pixelCollision,
                    currentProjectile.posX, currentProjectile.posY, currentProjectile.width, currentProjectile.height, currentProjectile.pixelCollision)){
                        
                        /*if(currentShield.health <= 0){
                            shieldList.splice(shieldNo, 1);
                            //Creo que no se ocupa al ser destruido el proyectil
                            //shieldNo--;
                        }*/

                        //Deal damage to shield
                        let projectileCenterX = currentProjectile.posX + currentProjectile.width / 2;
                        let explosionX = projectileCenterX - enemyProjectileExplosionObject.width / 2;

                        //Generate new image for the shield alongside dealing damage
                        damageShield(currentShield, enemyProjectileExplosionObject, explosionX, currentProjectile.posY);
                        
                        /*conversionCanvas.width = defaultShieldWidth
                        conversionCanvas.height = defaultShieldHeight;
                        conversionCtx.clearRect(0, 0, conversionCanvas.width, conversionCanvas.height);
                        conversionCtx.drawImage(imgShield, 0, 0, defaultShieldWidth, defaultShieldHeight);
                        currentShield.image = conversionCtx.getImageData(0, 0, defaultShieldWidth, defaultShieldHeight);*/

                        removeProjectile = true;
                        break;
                    }
                }

            }

            if(removeProjectile){
                enemyProjectileList.splice(projectileNo, 1);
                projectileNo--;
                continue;
            }

            //Check if projectile hits player
            if(checkCollision(currentProjectile.posX, currentProjectile.width,
            currentProjectile.posY, currentProjectile.height,
            playerPosX, playerWidth, playerPosY, playerHeight)){
                //TODO Activate game over check and all that
                loseLife();
                removeProjectile = true;
            }

            if(removeProjectile){
                enemyProjectileList.splice(projectileNo, 1);
                projectileNo--;
                continue;
            }

            //Projectile reaches end of screen
            if(currentProjectile.posY >= enemyProjectileYLimit){
                addTempSprite(imgAlienProjectileExplosion, tempSpriteAlienProjectileExplosionDuration, currentProjectile.posX, enemyProjectileYLimit, tempSpriteAlienProjectileExplosionWidth, tempSpriteAlienProjectileExplosionHeight);
                enemyProjectileList.splice(projectileNo, 1);
                projectileNo--;
            }
        }

        
        
        //Pass time for temporal sprites
        for(let spriteNo = 0; spriteNo < tempSpriteList.length; spriteNo++){
            
            let currentSprite = tempSpriteList[spriteNo];
            currentSprite.frames--;

            if(currentSprite.frames <= 0){
                tempSpriteList.splice(spriteNo, 1);
                spriteNo--;
            }
        }
    };

    var downedLoop = () => {
        if(playerCurrentImage == imgDefenderExplode1){
            playerCurrentImage = imgDefenderExplode2
        }
        else{
            playerCurrentImage = imgDefenderExplode1
        }

        drawItems();

        downedCurrentLoop++;

        if(downedCurrentLoop >= downedLoops){
            playerCurrentImage = imgDefender;

            clearInterval(gameInterval);

            if(lives <= 0){
                gameOver();
            }
            else{
                gameInterval = setInterval(gameLoop, timeFraction);
            }
        }
    }

    var drawItems = () => {
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
        
        //Draw score
        ctx.font = "30px Arial";
        ctx.fillStyle = "#ffffff";
        txtScore = "Score: " + score;
        ctx.fillText(txtScore, 10, 30);

        txtHighscore = "Hi-Score: " + highScore;
        ctx.fillText(txtHighscore, 300, 30);

        //Draw aliens
        let alienLength = alienList.length;
        for(let alienNo = 0; alienNo < alienLength; alienNo++){
            //console.log("Gone through alien no: ", alienNo);
            let currentAlien = alienList[alienNo];
            //console.log(currentAlien);
            ctx.drawImage(imgAlien, currentAlien.posX, currentAlien.posY, currentAlien.width, currentAlien.height);
        }

        //Draw UFO
        let UFOLength = UFOList.length;
        for(let UFONo = 0; UFONo < UFOLength; UFONo++){
            let currentUFO = UFOList[UFONo];
            ctx.drawImage(imgUFO, currentUFO.posX, currentUFO.posY, currentUFO.width, currentUFO.height);
        }

        //Draw shields
        let shieldLength = shieldList.length;
        for(let shieldNo = 0; shieldNo < shieldLength; shieldNo++){
            let currentShield = shieldList[shieldNo];
            //console.log(currentShield.image);
            ctx.drawImage(currentShield.image, currentShield.posX, currentShield.posY, currentShield.width, currentShield.height);
            //console.log(currentShield.image);
            //ctx.putImageData(currentShield.image, currentShield.posX, currentShield.posY);
        }

        //Draw player
        ctx.drawImage(playerCurrentImage, playerPosX, playerPosY, playerWidth, playerHeight);

        //Draw friendly projectiles
        let listLength = playerProjectileList.length;
        for(let i = 0; i < listLength; i++){
            let current = playerProjectileList[i];
            ctx.drawImage(imgProjectile, current.posX, current.posY, current.width, current.height);
        }

        //Draw enemy projectiles
        listLength = enemyProjectileList.length;
        for(let i = 0; i < listLength; i++){
            let current = enemyProjectileList[i];
            ctx.drawImage(imgEnemyProjectile, current.posX, current.posY, current.width, current.height);
        }

        //Draw temp sprites
        listLength = tempSpriteList.length;
        for(let i = 0; i < listLength; i++){
            let current = tempSpriteList[i];
            ctx.drawImage(current.image, current.posX, current.posY, current.width, current.height);
        }

        //Draw lives
        ctx.font = "20px Arial";
        ctx.fillText(lives, 10, 590);
        let initialXDrawingPos = 50;
        for(let i = 1; i < lives; i++){
            ctx.drawImage(imgDefender, (35*i), 575, 30, 15)
        }
        ctx.fillStyle = "#00FF00"
        ctx.fillRect(0, 565, 800, 3);
    }

    var handleInput = () => {
        //Check input and handle it
        if(keyLeft == true){
            if((playerPosX - playerSpeed) >= playerLimitXLeft){
                playerPosX -= playerSpeed;
            }
        }
        if(keyRight == true){
            if((playerPosX + playerWidth + playerSpeed) <= playerLimitXRight){
                playerPosX += playerSpeed;
            }
        }
        if(keyShoot == true){
            if(playerProjectileList.length < maxPlayerProjectiles && shotInputReleased == true && playerProjectileCurrentReload <= 0){
                //Shoot projectile
                //Center projectile based on player
                let centerPlayerX = playerPosX + (playerWidth / 2);
                let projectileX = centerPlayerX - (playerProjectileWidth / 2);

                let newPixelCollision = {
                    data: playerProjectileObject.data.slice(),
                    width: enemyProjectileWidth,
                    height: enemyProjectileHeight
                };

                let projectile = {
                    posX: projectileX,
                    posY: playerPosY,
                    width: playerProjectileWidth,
                    height: playerProjectileHeight,
                    pixelCollision: newPixelCollision
                };

                //console.log("New projectile:", projectile);

                playerProjectileList.push(projectile);
            }
            shotInputReleased = false;
        }
        else if(keyShoot == false){
            shotInputReleased = true;
        }
    }

    var restartGame = () => {
        //console.log("Restarted");
        
        if(gameInterval != null){
            clearInterval(gameInterval);
        }

        document.removeEventListener('keydown', handleKeyDown);
        document.removeEventListener('keyup', handleKeyUp);
        //gameStarted = 1;

        //Prepare score
        score = 0;

        //Prepare lives
        lives = defaultLives;

        //Add aliens to game
        alienCurrentFrozenTime = 0;
        alienList = [];
        alienMovementRows = [];
        alienCurrentMovementIndex = alienRows - 1;
        var alienFlagDirection = false;
        let initialX = 400 - ((alienColumns * alienWidth + alienXSeparation * (alienColumns - 1)) / 2);        
        let initialY = alienYStart;
        let currentY = initialY;

        //Create alien rows
        for(let row = 0; row < alienRows; row++){
            alienMovementRows.push(row);

            let currentX = initialX;

            for(let column = 0; column < alienColumns; column++){
                //Make the pixel collision rectangular
                let totalPixels = alienWidth * alienHeight;
                let collisionData = [];
                for(let i = 0; i < totalPixels; i++){
                    collisionData.push(1);
                }

                let newPixelCollision = {
                    data: collisionData,
                    width: alienWidth,
                    height: alienHeight
                }

                let alien = {
                    row: row,
                    column: column,
                    posX: currentX,
                    posY: currentY,
                    width: alienWidth,
                    height: alienHeight,
                    pixelCollision: newPixelCollision
                };

                alienList.push(alien);

                currentX += alienXSeparation + alienWidth;

                if(row == alienRows - 1){
                    bottomAliens.push(alien);
                    //console.log("Bottom Aliens:", bottomAliens);
                }
            }

            currentY += alienYSeparation + alienHeight;
        }

        //Add player
        playerPosX = playerInitialPosX;
        playerPosY = playerInitialPosY;

        //Add shields
        shieldList = [];
        let currentX = 0;
        let halfShieldSeparation = (800 - defaultShields * defaultShieldWidth) / (defaultShields + 1);
        for(let shieldNo = 0; shieldNo < defaultShields; shieldNo++){
            currentX += halfShieldSeparation;

            //Create a destructible object for the shield
            let newPixelCollision = {
                data: defaultDestructibleObject.data.slice(),
                width: defaultDestructibleObject.width,
                height: defaultDestructibleObject.height
            };

            //Give each image object their own
            conversionCanvas.width = defaultShieldWidth;
            conversionCanvas.height = defaultShieldHeight;
            conversionCtx.clearRect(0, 0, conversionCanvas.width, conversionCanvas.height);
            conversionCtx.drawImage(imgShield, 0, 0, defaultShieldWidth, defaultShieldHeight);
            
            //let shieldImageData = conversionCtx.getImageData(0, 0, defaultShieldWidth, defaultShieldHeight);
            let shieldImage = new Image();
            shieldImage.src = conversionCanvas.toDataURL();

            let shield = {
                width: defaultShieldWidth,
                height: defaultShieldHeight,
                posX: currentX,
                posY: defaultShieldPosY,
                health: defaultShieldHealth,
                pixelCollision: newPixelCollision,
                image: shieldImage
            };

            currentX += defaultShieldWidth;

            shieldList.push(shield);
        }

        tempSpriteList = [];

        gameInterval = setInterval(gameLoop, timeFraction);

        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);
    }

    var handleKeyDown = () =>{
        if(event.keyCode == 37 && keyLeft == false) {
            keyLeft = true;
            //console.log('Left was pressed');
        }
        else if(event.keyCode == 39 && keyRight == false) {
            keyRight = true;
            //console.log('Right was pressed');
        }
        else if(event.keyCode == 65 && keyShoot == false) {
            keyShoot = true;
            //console.log('A was pressed');
        }
    }

    var handleKeyUp = () => {
        if(event.keyCode == 37 && keyLeft == true) {
            keyLeft = false;
            //console.log('Left was released');
        }
        else if(event.keyCode == 39 && keyRight == true) {
            keyRight = false;
            //console.log('Right was released');
        }
        else if(event.keyCode == 65 && keyShoot == true) {
            keyShoot = false;
            //console.log('A was pressed');
        }
    }

    var addScore = (points) => {
        score += points;

        if(score > highScore){
            highScore = score;
        }
    }

    //This is used after the alien is destroyed
    var speedAliensUp = () => {
        let startingAliens = alienRows * alienColumns;
        let totalAliens = alienList.length;

        if(totalAliens % alienRows == 0){
            alienAcceleratedFPS *= alienReduceFPSWaitPercentage - Math.round(startingAliens / totalAliens) * 0.04;
        }

        if(totalAliens < alienColumns){
            //alienAcceleratedFPS *= alienReduceFPSWaitPercentage - (alienColumns / totalAliens) * 0.1;
            alienAcceleratedFPS = (totalAliens/alienColumns) * 1;
        }
        else{
            alienAcceleratedFPS *= alienReduceFPSWaitPercentage;
        }

        /*if(totalAliens == 2){
            alienAcceleratedFPS = 0.1;
        }

        if(totalAliens == 1){
            alienAcceleratedFPS = 0;
        }*/

        if(alienAcceleratedFPS <= 0){
            alienAcceleratedFPS = 0;
        }
    }

    var loseLife = () => {
        lives--;

        clearInterval(gameInterval);
        playerCurrentImage = imgDefenderExplode1;
        drawItems();

        downedCurrentLoop = 0;
        gameInterval = setInterval(downedLoop, downedAnimationDelay);

        /*if(lives <= 0){
            gameOver();
        }*/
    }

    var gameOver = () => {
        if(gameInterval != null){
            clearInterval(gameInterval);
        }

        document.removeEventListener('keydown', handleKeyDown);
        document.removeEventListener('keyup', handleKeyUp);

        //Draw score
        ctx.font = "30px Arial";
        ctx.fillStyle = "#ffffff";
        txtScore = "Game over";
        ctx.fillText(txtScore, 300, 100);
    }

    var checkCollision = (x1, width1, y1, height1, x2, width2, y2, height2) => {
        return x1 + width1 > x2 && 
            x2 + width2 > x1 && 
            y1 + height1 > y2 &&
            y2 + height2 > y1;
    }

    var checkPixelCollision = (xA, yA, widthA, heightA, pCA, xB, yB, widthB, heightB, pCB) => {
        //Adjust the difference in position
        let differenceX = xB - xA;
        let differenceY = yB - yA;

        for(let aRow = 0; aRow < heightA; aRow++){
            //Skip row B if row A is above the row B
            if(aRow < differenceY){
                continue;
            }

            //Skip row B if row A is under the row B
            if(aRow > heightB - 1 + differenceY){
                continue;
            }

            for(let aCol = 0; aCol < widthA; aCol++){

                //Skip col B if col A is left of the col B
                if(aCol < differenceX){
                    continue;
                }

                //Skip col B if col A is right of the col B
                if(aCol > widthB - 1 + differenceX){
                    continue;
                }

                //Skip if there isn't anything to collide
                let aPointer = aCol + widthA * aRow;
                if(pCA.data[aPointer] == 0){
                    continue;
                }

                for(let bRow = 0; bRow < heightB; bRow++){
                    for(let bCol = 0; bCol < widthB; bCol++){
                        let bPointer = bCol + widthB * bRow;

                        //Skip if there isn't anything to collide with
                        if(pCB.data[bPointer] == 0){
                            continue;
                        }
                        else{
                            return true;
                        }
                    }
                }

            }
        }

        return false;
    }

    var damageShield = (shield, shape, shapeX, shapeY) => {
        //A is shield
        //B is damage shape
        //console.log("Shield object: ", shield);
        //console.log("Explosion shape:", shape);

        let listPixelsToChange = [];

        //Adjust the difference in position
        let differenceX = shapeX - shield.posX;
        let differenceY = shapeY - shield.posY;

        for(let aRow = 0; aRow < shield.width; aRow++){
            //Skip row B if row A is above the row B
            if(aRow < differenceY){
                continue;
            }

            //Skip row B if row A is under the row B
            if(aRow > shape.height - 1 + differenceY){
                continue;
            }

            for(let aCol = 0; aCol < shield.width; aCol++){

                //Skip col B if col A is left of the col B
                if(aCol < differenceX){
                    continue;
                }

                //Skip col B if col A is right of the col B
                if(aCol > shape.width - 1 + differenceX){
                    continue;
                }

                //Skip if there isn't anything to collide
                let aPointer = aCol + shield.width * aRow;
                if(shield.pixelCollision.data[aPointer] == 0){
                    continue;
                }

                for(let bRow = 0; bRow < shape.height; bRow++){
                    for(let bCol = 0; bCol < shape.width; bCol++){
                        let bPointer = bCol + shape.width * bRow;

                        //Skip if there isn't anything to collide with
                        if(shape.data[bPointer] == 0){
                            continue;
                        }
                        else{
                            //This should be when there is a collision!
                            //Remove the part where there is a collision
                            //console.log("Collision position:", aPointer);
                            shield.pixelCollision.data[aPointer] = 0;

                            //Add pixel to change and position to list
                            listPixelsToChange.push(aPointer);
                        }
                    }
                }

            }
        }

        //console.log("Remove spaces phase");

        //Remove the empty spaces from the shield image
        conversionCanvas.width = defaultShieldWidth
        conversionCanvas.height = defaultShieldHeight;
        conversionCtx.clearRect(0, 0, conversionCanvas.width, conversionCanvas.height);
        conversionCtx.drawImage(shield.image, 0, 0, defaultShieldWidth, defaultShieldHeight);

        let tempShieldImageData = conversionCtx.getImageData(0, 0, defaultShieldWidth, defaultShieldHeight)

        //Remove the empty spaces from the image using the list of collision obtained
        for(let pointer = 0; pointer < listPixelsToChange.length; pointer++){
            let pixelPosition = listPixelsToChange[pointer];

            let imagePixelPosition = 4 * pixelPosition;

            tempShieldImageData.data[imagePixelPosition] = 0;
            tempShieldImageData.data[imagePixelPosition + 1] = 0;
            tempShieldImageData.data[imagePixelPosition + 2] = 0;
            tempShieldImageData.data[imagePixelPosition + 3] = 0;
        }

        conversionCtx.clearRect(0, 0, conversionCanvas.width, conversionCanvas.height);
        //conversionCtx.putImageData(tempShieldImageData, 0, 0, defaultShieldWidth, defaultShieldHeight);
        conversionCtx.putImageData(tempShieldImageData, 0, 0);
        
        //let shieldImageData = conversionCtx.getImageData(0, 0, defaultShieldWidth, defaultShieldHeight);
        shield.image.src = conversionCanvas.toDataURL();

        //console.log("Ended removal spaces phase");
    }

    var addTempSprite = (img, frames, posX, posY, width, height) => {
        let sprite = {
            image: img,
            frames: frames,
            posX: posX,
            posY: posY,
            width: width,
            height: height
        };

        tempSpriteList.push(sprite);
    }
</script>